//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.7

use std::time::UNIX_EPOCH;

use chrono::{ DateTime, Utc, TimeZone };
use rust_decimal::Decimal;
use serde::{ Deserialize, Serialize };

use crate::error::AppError;

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "snake_case")]
pub(crate) enum MaintenanceFrequencyOptions {
    OneTime,
    Monthly,
    Quarterly,
    Annually,
    AsNeeded,
}

impl MaintenanceFrequencyOptions {
    pub(crate) fn to_string(&self) -> String {
        match self {
            &MaintenanceFrequencyOptions::OneTime => "one-time".to_string(),
            &MaintenanceFrequencyOptions::Annually => "annually".to_string(),
            &MaintenanceFrequencyOptions::Quarterly => "quarterly".to_string(),
            &MaintenanceFrequencyOptions::Monthly => "monthly".to_string(),
            &MaintenanceFrequencyOptions::AsNeeded => "as-needed".to_string(),
        }
    }
    pub(crate) fn to_str(&self) -> &str {
        match self {
            &MaintenanceFrequencyOptions::OneTime => "one-time",
            &MaintenanceFrequencyOptions::Annually => "annually",
            &MaintenanceFrequencyOptions::Quarterly => "quarterly",
            &MaintenanceFrequencyOptions::Monthly => "monthly",
            &MaintenanceFrequencyOptions::AsNeeded => "as-needed",
        }
    }
    pub(crate) fn from_string(s: &str) -> Result<MaintenanceFrequencyOptions, AppError> {
        match s {
            "one-time" => Ok(Self::OneTime),
            "annually" => Ok(Self::Annually),
            "quarterly" => Ok(Self::Quarterly),
            "monthly" => Ok(Self::Monthly),
            "as-needed" => Ok(Self::AsNeeded),
            _ => {
                return Err(
                    AppError::DatabaseError(
                        "Invalid maintenance frequency option string for asset".to_string()
                    )
                );
            }
        }
    }
    pub(crate) fn to_days(f: &MaintenanceFrequencyOptions) -> Result<i32, AppError> {
        match f {
            &MaintenanceFrequencyOptions::OneTime => Ok(0),
            &MaintenanceFrequencyOptions::Annually => Ok(365),
            &MaintenanceFrequencyOptions::Quarterly => Ok(90),
            &MaintenanceFrequencyOptions::Monthly => Ok(30),
            &MaintenanceFrequencyOptions::AsNeeded => Ok(0),
            _ => {
                return Err(
                    AppError::DatabaseError(
                        "Invalid maintenance frequency option for asset".to_string()
                    )
                );
            }
        }
    }
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "snake_case")]
pub(crate) enum AssetCurrentStatusOptions {
    Operational,
    Down,
    Maintenance,
    Retired,
    NeedsAttention,
}

impl AssetCurrentStatusOptions {
    pub(crate) fn to_string(&self) -> String {
        match self {
            &AssetCurrentStatusOptions::Operational => "operational".to_string(),
            &AssetCurrentStatusOptions::Down => "down".to_string(),
            &AssetCurrentStatusOptions::Maintenance => "maintenance".to_string(),
            &AssetCurrentStatusOptions::Retired => "retired".to_string(),
            &AssetCurrentStatusOptions::NeedsAttention => "needs-attention".to_string(),
        }
    }
    pub(crate) fn to_str(&self) -> &str {
        match self {
            &AssetCurrentStatusOptions::Operational => "operational",
            &AssetCurrentStatusOptions::Down => "down",
            &AssetCurrentStatusOptions::Maintenance => "maintenance",
            &AssetCurrentStatusOptions::Retired => "retired",
            &AssetCurrentStatusOptions::NeedsAttention => "needs-attention",
        }
    }
    pub(crate) fn from_string(s: &str) -> Result<AssetCurrentStatusOptions, AppError> {
        match s {
            "operational" => Ok(Self::Operational),
            "down" => Ok(Self::Down),
            "maintenance" => Ok(Self::Maintenance),
            "retired" => Ok(Self::Retired),
            "needs-attention" => Ok(Self::NeedsAttention),
            _ => {
                return Err(
                    AppError::DatabaseError(
                        "Invalid maintenance frequency option string for asset".to_string()
                    )
                );
            }
        }
    }
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Asset {
    pub id: String,
    pub name: String,
    pub r#type_id: String,
    pub serial_number: String,
    pub model_number: String,
    pub purchase_date: DateTime<Utc>,
    pub installation_date: DateTime<Utc>,
    pub current_status: String,
    pub location_id: String,
    pub manufacturer_id: String,
    pub maintenance_frequency: MaintenanceFrequencyOptions,
    pub interval_days: i32,
    pub documentation_keys: Vec<String>,
    pub work_order_ids: Vec<String>,
    pub warranty_start_date: Option<DateTime<Utc>>,
    pub warranty_end_date: Option<DateTime<Utc>>,
    pub total_downtime_hours: Decimal,
    pub last_downtime_date: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub created_at: DateTime<Utc>,
}

impl Asset {
    pub fn new(
        id: String,
        name: String,
        r#type_id: String,
        serial_number: String,
        model_number: String,
        purchase_date: DateTime<Utc>,
        installation_date: DateTime<Utc>,
        location_id: String,
        manufacturer_id: String,
        maintenance_frequency: String,
        last_downtime_date: Option<DateTime<Utc>>,
        warranty_start_date: Option<DateTime<Utc>>,
        warranty_end_date: Option<DateTime<Utc>>
    ) -> Result<Self, AppError> {
        let now = Utc::now();

        let maint_freq = MaintenanceFrequencyOptions::from_string(&maintenance_frequency)?;
        let maint_freq_days = MaintenanceFrequencyOptions::to_days(&maint_freq)?;
        let curr_status = AssetCurrentStatusOptions::Operational.to_string();
        let last_downtime_date_default = Utc.timestamp_opt(0, 0)
            .single()
            .unwrap_or(Utc.timestamp_opt(0, 0).earliest().unwrap());

        let new_last_downtime_date = match &last_downtime_date {
            Some(d) => d,
            None => &last_downtime_date_default,
        };

        Ok(Self {
            id,
            name,
            r#type_id,
            serial_number,
            model_number,
            purchase_date,
            installation_date,
            current_status: curr_status,
            location_id,
            manufacturer_id,
            maintenance_frequency: maint_freq,
            interval_days: maint_freq_days,
            documentation_keys: Vec::new(),
            work_order_ids: Vec::new(),
            warranty_start_date,
            warranty_end_date,
            total_downtime_hours: Decimal::new(0, 0),
            last_downtime_date: *new_last_downtime_date,
            created_at: now,
            updated_at: now,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::{ DateTime, Utc, TimeZone };
    use rust_decimal::Decimal;

    // Helper functions
    fn create_valid_asset() -> Result<Asset, AppError> {
        Asset::new(
            "asset-123".to_string(),
            "Test Pump".to_string(),
            "type-456".to_string(),
            "SN12345".to_string(),
            "Model-ABC".to_string(),
            Utc::now(),
            Utc::now(),
            "loc-789".to_string(),
            "mfg-101".to_string(),
            "monthly".to_string(),
            None, // last_downtime_date
            Some(Utc::now()),
            Some(Utc::now())
        )
    }

    fn create_minimal_asset() -> Result<Asset, AppError> {
        Asset::new(
            "asset-minimal".to_string(),
            "Minimal Asset".to_string(),
            "type-minimal".to_string(),
            "SN00000".to_string(),
            "Model-MIN".to_string(),
            Utc::now(),
            Utc::now(),
            "loc-minimal".to_string(),
            "mfg-minimal".to_string(),
            "as-needed".to_string(),
            None,
            None,
            None
        )
    }

    // MaintenanceFrequencyOptions tests
    #[test]
    fn test_maintenance_frequency_to_string() {
        assert_eq!(MaintenanceFrequencyOptions::OneTime.to_string(), "one-time");
        assert_eq!(MaintenanceFrequencyOptions::Monthly.to_string(), "monthly");
        assert_eq!(MaintenanceFrequencyOptions::Quarterly.to_string(), "quarterly");
        assert_eq!(MaintenanceFrequencyOptions::Annually.to_string(), "annually");
        assert_eq!(MaintenanceFrequencyOptions::AsNeeded.to_string(), "as-needed");
    }

    #[test]
    fn test_maintenance_frequency_to_str() {
        assert_eq!(MaintenanceFrequencyOptions::OneTime.to_str(), "one-time");
        assert_eq!(MaintenanceFrequencyOptions::Monthly.to_str(), "monthly");
        assert_eq!(MaintenanceFrequencyOptions::Quarterly.to_str(), "quarterly");
        assert_eq!(MaintenanceFrequencyOptions::Annually.to_str(), "annually");
        assert_eq!(MaintenanceFrequencyOptions::AsNeeded.to_str(), "as-needed");
    }

    #[test]
    fn test_maintenance_frequency_from_string_valid() {
        assert!(
            matches!(
                MaintenanceFrequencyOptions::from_string("one-time").unwrap(),
                MaintenanceFrequencyOptions::OneTime
            )
        );
        assert!(
            matches!(
                MaintenanceFrequencyOptions::from_string("monthly").unwrap(),
                MaintenanceFrequencyOptions::Monthly
            )
        );
        assert!(
            matches!(
                MaintenanceFrequencyOptions::from_string("quarterly").unwrap(),
                MaintenanceFrequencyOptions::Quarterly
            )
        );
        assert!(
            matches!(
                MaintenanceFrequencyOptions::from_string("annually").unwrap(),
                MaintenanceFrequencyOptions::Annually
            )
        );
        assert!(
            matches!(
                MaintenanceFrequencyOptions::from_string("as-needed").unwrap(),
                MaintenanceFrequencyOptions::AsNeeded
            )
        );
    }

    #[test]
    fn test_maintenance_frequency_from_string_invalid() {
        let result = MaintenanceFrequencyOptions::from_string("invalid");
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), AppError::DatabaseError(_)));
    }

    #[test]
    fn test_maintenance_frequency_to_days() {
        assert_eq!(
            MaintenanceFrequencyOptions::to_days(&MaintenanceFrequencyOptions::OneTime).unwrap(),
            0
        );
        assert_eq!(
            MaintenanceFrequencyOptions::to_days(&MaintenanceFrequencyOptions::Monthly).unwrap(),
            30
        );
        assert_eq!(
            MaintenanceFrequencyOptions::to_days(&MaintenanceFrequencyOptions::Quarterly).unwrap(),
            90
        );
        assert_eq!(
            MaintenanceFrequencyOptions::to_days(&MaintenanceFrequencyOptions::Annually).unwrap(),
            365
        );
        assert_eq!(
            MaintenanceFrequencyOptions::to_days(&MaintenanceFrequencyOptions::AsNeeded).unwrap(),
            0
        );
    }

    // AssetCurrentStatusOptions tests
    #[test]
    fn test_asset_status_to_string() {
        assert_eq!(AssetCurrentStatusOptions::Operational.to_string(), "operational");
        assert_eq!(AssetCurrentStatusOptions::Down.to_string(), "down");
        assert_eq!(AssetCurrentStatusOptions::Maintenance.to_string(), "maintenance");
        assert_eq!(AssetCurrentStatusOptions::Retired.to_string(), "retired");
        assert_eq!(AssetCurrentStatusOptions::NeedsAttention.to_string(), "needs-attention");
    }

    #[test]
    fn test_asset_status_to_str() {
        assert_eq!(AssetCurrentStatusOptions::Operational.to_str(), "operational");
        assert_eq!(AssetCurrentStatusOptions::Down.to_str(), "down");
        assert_eq!(AssetCurrentStatusOptions::Maintenance.to_str(), "maintenance");
        assert_eq!(AssetCurrentStatusOptions::Retired.to_str(), "retired");
        assert_eq!(AssetCurrentStatusOptions::NeedsAttention.to_str(), "needs-attention");
    }

    #[test]
    fn test_asset_status_from_string_valid() {
        assert!(
            matches!(
                AssetCurrentStatusOptions::from_string("operational").unwrap(),
                AssetCurrentStatusOptions::Operational
            )
        );
        assert!(
            matches!(
                AssetCurrentStatusOptions::from_string("down").unwrap(),
                AssetCurrentStatusOptions::Down
            )
        );
        assert!(
            matches!(
                AssetCurrentStatusOptions::from_string("maintenance").unwrap(),
                AssetCurrentStatusOptions::Maintenance
            )
        );
        assert!(
            matches!(
                AssetCurrentStatusOptions::from_string("retired").unwrap(),
                AssetCurrentStatusOptions::Retired
            )
        );
        assert!(
            matches!(
                AssetCurrentStatusOptions::from_string("needs-attention").unwrap(),
                AssetCurrentStatusOptions::NeedsAttention
            )
        );
    }

    #[test]
    fn test_asset_status_from_string_invalid() {
        let result = AssetCurrentStatusOptions::from_string("invalid-status");
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), AppError::DatabaseError(_)));
    }

    // Asset constructor tests
    #[test]
    fn test_asset_new_with_valid_data() {
        let asset = create_valid_asset().unwrap();

        assert_eq!(asset.id, "asset-123");
        assert_eq!(asset.name, "Test Pump");
        assert_eq!(asset.r#type_id, "type-456");
        assert_eq!(asset.serial_number, "SN12345");
        assert_eq!(asset.model_number, "Model-ABC");
        assert_eq!(asset.location_id, "loc-789");
        assert_eq!(asset.manufacturer_id, "mfg-101");
        assert_eq!(asset.current_status, "operational");
        assert!(matches!(asset.maintenance_frequency, MaintenanceFrequencyOptions::Monthly));
        assert_eq!(asset.interval_days, 30);
        assert_eq!(asset.documentation_keys.len(), 0);
        assert_eq!(asset.work_order_ids.len(), 0);
        assert_eq!(asset.total_downtime_hours, Decimal::new(0, 0));

        // Check that last_downtime_date defaults to Unix epoch when None provided
        let unix_epoch = Utc.timestamp_opt(0, 0).single().unwrap();
        assert_eq!(asset.last_downtime_date, unix_epoch);

        // Check timestamps
        assert!(asset.created_at <= Utc::now());
        assert!(asset.updated_at <= Utc::now());
        assert_eq!(asset.created_at, asset.updated_at);
    }

    #[test]
    fn test_asset_new_with_minimal_data() {
        let asset = create_minimal_asset().unwrap();

        assert_eq!(asset.id, "asset-minimal");
        assert_eq!(asset.name, "Minimal Asset");
        assert_eq!(asset.current_status, "operational");
        assert!(matches!(asset.maintenance_frequency, MaintenanceFrequencyOptions::AsNeeded));
        assert_eq!(asset.interval_days, 0);
        assert_eq!(asset.warranty_start_date, None);
        assert_eq!(asset.warranty_end_date, None);

        // Check that last_downtime_date defaults to Unix epoch
        let unix_epoch = Utc.timestamp_opt(0, 0).single().unwrap();
        assert_eq!(asset.last_downtime_date, unix_epoch);
    }

    #[test]
    fn test_asset_new_with_custom_last_downtime_date() {
        let custom_downtime = Utc::now() - chrono::Duration::days(5);

        let asset = Asset::new(
            "asset-custom".to_string(),
            "Custom Asset".to_string(),
            "type-custom".to_string(),
            "SN-CUSTOM".to_string(),
            "Model-Custom".to_string(),
            Utc::now(),
            Utc::now(),
            "loc-custom".to_string(),
            "mfg-custom".to_string(),
            "monthly".to_string(),
            Some(custom_downtime),
            None,
            None
        ).unwrap();

        assert_eq!(asset.last_downtime_date, custom_downtime);
    }

    #[test]
    fn test_asset_new_with_warranty_dates() {
        let warranty_start = Utc::now();
        let warranty_end = warranty_start + chrono::Duration::days(365);

        let asset = Asset::new(
            "asset-warranty".to_string(),
            "Warranty Asset".to_string(),
            "type-warranty".to_string(),
            "SN-WARRANTY".to_string(),
            "Model-Warranty".to_string(),
            Utc::now(),
            Utc::now(),
            "loc-warranty".to_string(),
            "mfg-warranty".to_string(),
            "annually".to_string(),
            None,
            Some(warranty_start),
            Some(warranty_end)
        ).unwrap();

        assert_eq!(asset.warranty_start_date, Some(warranty_start));
        assert_eq!(asset.warranty_end_date, Some(warranty_end));
        assert_eq!(asset.interval_days, 365);
    }

    #[test]
    fn test_asset_new_with_invalid_maintenance_frequency() {
        let result = Asset::new(
            "asset-invalid".to_string(),
            "Invalid Asset".to_string(),
            "type-invalid".to_string(),
            "SN-INVALID".to_string(),
            "Model-Invalid".to_string(),
            Utc::now(),
            Utc::now(),
            "loc-invalid".to_string(),
            "mfg-invalid".to_string(),
            "invalid-frequency".to_string(),
            None,
            None,
            None
        );

        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), AppError::DatabaseError(_)));
    }

    #[test]
    fn test_asset_default_values() {
        let asset = create_valid_asset().unwrap();

        // Verify default collections are empty
        assert!(asset.documentation_keys.is_empty());
        assert!(asset.work_order_ids.is_empty());

        // Verify default numeric values
        assert_eq!(asset.total_downtime_hours, Decimal::new(0, 0));

        // Verify default status
        assert_eq!(asset.current_status, "operational");

        // Verify Unix epoch default for last_downtime_date
        let unix_epoch = Utc.timestamp_opt(0, 0).single().unwrap();
        assert_eq!(asset.last_downtime_date, unix_epoch);
    }

    #[test]
    fn test_asset_timestamps_consistency() {
        let before = Utc::now();
        let asset = create_valid_asset().unwrap();
        let after = Utc::now();

        assert!(asset.created_at >= before);
        assert!(asset.created_at <= after);
        assert!(asset.updated_at >= before);
        assert!(asset.updated_at <= after);
        assert_eq!(asset.created_at, asset.updated_at);
    }

    #[test]
    fn test_asset_clone() {
        let asset = create_valid_asset().unwrap();
        let cloned = asset.clone();

        assert_eq!(asset.id, cloned.id);
        assert_eq!(asset.name, cloned.name);
        assert_eq!(asset.r#type_id, cloned.r#type_id);
        assert_eq!(asset.serial_number, cloned.serial_number);
        assert_eq!(asset.model_number, cloned.model_number);
        assert_eq!(asset.purchase_date, cloned.purchase_date);
        assert_eq!(asset.installation_date, cloned.installation_date);
        assert_eq!(asset.current_status, cloned.current_status);
        assert_eq!(asset.location_id, cloned.location_id);
        assert_eq!(asset.manufacturer_id, cloned.manufacturer_id);
        assert_eq!(asset.interval_days, cloned.interval_days);
        assert_eq!(asset.documentation_keys, cloned.documentation_keys);
        assert_eq!(asset.work_order_ids, cloned.work_order_ids);
        assert_eq!(asset.warranty_start_date, cloned.warranty_start_date);
        assert_eq!(asset.warranty_end_date, cloned.warranty_end_date);
        assert_eq!(asset.total_downtime_hours, cloned.total_downtime_hours);
        assert_eq!(asset.last_downtime_date, cloned.last_downtime_date);
        assert_eq!(asset.created_at, cloned.created_at);
        assert_eq!(asset.updated_at, cloned.updated_at);
    }

    #[test]
    fn test_maintenance_frequency_enum_consistency() {
        let frequencies = vec![
            MaintenanceFrequencyOptions::OneTime,
            MaintenanceFrequencyOptions::Monthly,
            MaintenanceFrequencyOptions::Quarterly,
            MaintenanceFrequencyOptions::Annually,
            MaintenanceFrequencyOptions::AsNeeded
        ];

        for freq in frequencies {
            let to_string_result = freq.to_string();
            let to_str_result = freq.to_str();
            assert_eq!(to_string_result, to_str_result);

            // Test roundtrip conversion
            let parsed = MaintenanceFrequencyOptions::from_string(&to_string_result).unwrap();
            assert_eq!(freq.to_str(), parsed.to_str());
        }
    }

    #[test]
    fn test_asset_status_enum_consistency() {
        let statuses = vec![
            AssetCurrentStatusOptions::Operational,
            AssetCurrentStatusOptions::Down,
            AssetCurrentStatusOptions::Maintenance,
            AssetCurrentStatusOptions::Retired,
            AssetCurrentStatusOptions::NeedsAttention
        ];

        for status in statuses {
            let to_string_result = status.to_string();
            let to_str_result = status.to_str();
            assert_eq!(to_string_result, to_str_result);

            // Test roundtrip conversion
            let parsed = AssetCurrentStatusOptions::from_string(&to_string_result).unwrap();
            assert_eq!(status.to_str(), parsed.to_str());
        }
    }
}
